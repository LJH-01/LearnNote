# 刷题记录

## 排序算法


### 堆排序
大顶堆的堆顶元素为当前堆的最大元素。
实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。


小顶堆的堆顶元素为当前堆的最小元素。
实现过程：不断地往小顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最小的元素，剩下的元素都为当前添加过的元素中最大的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。


堆排序的实现原理是：
新加入的元素放入到堆的尾部，
改元素和其父元素比较，如果改元素小于父元素，则将父元素放入到改元素的位置，该元素放到父元素的位置,继续进行改步骤，直到该元素大于父元素，并把当前位置设置为该元素。

```java
public class MyPQ<E> extends PriorityQueue<E> {

    transient Object[] queue; // non-private to simplify nested class access
    
    private int size = 0;
    
    transient int modCount = 0;

    public MyPQ(int initialCapacity) {
        super(initialCapacity, null);
        queue = new Object[initialCapacity];
    }
    
    public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        size = i + 1;
        if (i == 0)
            queue[0] = e;
        else
            siftUpComparable(i, e);
        return true;
    }

    private void siftUpComparable(int k, E x) {
        Comparable<? super E> key = (Comparable<? super E>) x;
        while (k > 0) {
            int parent = (k - 1) >>> 1;
            Object e = queue[parent];
            // 该元素大于父元素
            if (key.compareTo((E) e) >= 0) {
                // 把当前位置设置为该元素。
                queue[k] = key;
                break;
            }
            // 元素和其父元素比较，如果改元素小于父元素，则将父元素放入到改元素的位置，该元素放到父元素的位置
            queue[k] = e;
            queue[parent] = key;

            k = parent;
        }
    }

}
```



## 贪心算法

### 之不重叠子区间

要点：按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。

### 之根据身高和序号重组队列

方法：先根据身高由高到低排列，然后依次插入，因为身高高的会影响身高低的前面的更高身高的个数，根据需要插入


### 股票买卖问题

只能买卖一次：遍历中标记处最小值，当前值与最小值比较，一次遍历出结果。

同时间只能持有一次：所有的赚钱的都能赚到，得到所有的price[i]-price[i-1]>0的和

## 二分查找

技巧：首先while循环是< 然后根据情况改为<=或者<

### 寻找旋转排序数组中的最小值问题

类似与求最左的数字

## 递归

技巧：就相当于数的遍历，注意结束条件

### 回溯算法

**回溯与递归的区别：回溯前后的数据会相互产生影响而递归不会。**

写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

方法通常是：backtrack(路径, 选择列表)

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。