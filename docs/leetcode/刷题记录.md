# 刷题记录

## 排序算法


### 堆排序
大顶堆的堆顶元素为当前堆的最大元素。
实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。


小顶堆的堆顶元素为当前堆的最小元素。
实现过程：不断地往小顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最小的元素，剩下的元素都为当前添加过的元素中最大的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。


堆排序的实现原理是：
新加入的元素放入到堆的尾部，
改元素和其父元素比较，如果改元素小于父元素，则将父元素放入到改元素的位置，该元素放到父元素的位置,继续进行改步骤，直到该元素大于父元素，并把当前位置设置为该元素。

```java
public class MyPQ<E> extends PriorityQueue<E> {

    transient Object[] queue; // non-private to simplify nested class access
    
    private int size = 0;
    
    transient int modCount = 0;

    public MyPQ(int initialCapacity) {
        super(initialCapacity, null);
        queue = new Object[initialCapacity];
    }
    
    public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        size = i + 1;
        if (i == 0)
            queue[0] = e;
        else
            siftUpComparable(i, e);
        return true;
    }

    private void siftUpComparable(int k, E x) {
        Comparable<? super E> key = (Comparable<? super E>) x;
        while (k > 0) {
            int parent = (k - 1) >>> 1;
            Object e = queue[parent];
            // 该元素大于父元素
            if (key.compareTo((E) e) >= 0) {
                // 把当前位置设置为该元素。
                queue[k] = key;
                break;
            }
            // 元素和其父元素比较，如果改元素小于父元素，则将父元素放入到改元素的位置，该元素放到父元素的位置
            queue[k] = e;
            queue[parent] = key;

            k = parent;
        }
    }

}
```


