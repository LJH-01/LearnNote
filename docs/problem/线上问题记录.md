[TOC]



# 线上问题记录

## 常规问题

### 问题1：长时间停顿、接口超时、线程内逻辑不执行以及CPU占用率过高等线程问题

使用：jstack命令结合线程状态使用。生成JVM当前的线程的快照

#### 线程状态

![image-20230510151445888](assets/image-20230510151445888.png)

1. 使用jps、ps -ef | grep java查看当前java进程的pid，严重情况下可以使用top命令查看当前系统cpu/内存使用率最高的进程pid。

![image-20230510150428951](assets/image-20230510150428951.png)

这里我们的死锁的pid是：3429，这里程序很简单，虽然程序死锁，没有占用很多资源。

2. 使用top -Hp 3429命令查看进程里面占用最多的资源的线程。

![image-20230510150449372](assets/image-20230510150449372.png)

这里我们看到的占用最多资源的线程是：3440。

3. 使用命令printf "%x\n" 3440 把线程pid转换成16进制数，得到：d70。

4. 使用jstack 3429 | grep -20 d70命令查询该线程阻塞的地方。

![image-20230510150529961](assets/image-20230510150529961.png)

到这里就基本跟踪完毕，去代码所在行看看为什么死锁吧。

#### 真正的线上问题的场景

1. 我们man端任务偶发性任务不行，偶尔执行，偶尔不执行
2. rpc接口超时，且不用rpc接口之间互相影响，导致机器大量超时

#### 小结

1. jps、ps -ef | grep java查看当前java进程的pid
2. 使用top -Hp XXX命令查看进程里面占用最多的资源的线程。
3. 使用命令printf "%x\n" 3440 把线程pid转换成16进制数
4. 使用jstack 3429 | grep -20 d70命令查询该线程或者使用stack



### 问题2：内存溢出







## 非常规问题







































## 参考

https://mp.weixin.qq.com/s/nRTBJKzgaGqR_M3JYwXyyQ